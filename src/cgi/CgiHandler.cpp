#include "CgiHandler.hpp"
#include <cerrno>
#include <csignal>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <fcntl.h>
#include <fstream>
#include <string>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

CgiHandler::CgiHandler(const Request& req, const Location& loc)
    : request(req), location(loc), script_path(""), cgi_executable("") {
}

CgiHandler::~CgiHandler() {
}

std::string CgiHandler::getFileExtension(const std::string& path) const {
    size_t dot_pos = path.find_last_of('.');
    if (dot_pos == std::string::npos) {
        return "";
    }
    return path.substr(dot_pos);
}

std::string CgiHandler::getCgiExecutable(const std::string& file_path) const{
    std::string extension = getFileExtension(file_path);
    const std::map<std::string, std::string>& cgi_map = location.getCgi();

    std::map<std::string, std::string>::const_iterator it = cgi_map.find(extension);
    if (it != cgi_map.end()) {
        return it->second;
    }
    return "";
}

Response CgiHandler::execute() {
    Response response;

    std::string extension = getFileExtension(request.path);
    if (extension.empty()) {
        response.generateErrorPage(request.server, 500);
        return response;
    }

    // Set script path and CGI executable
    script_path = request.path;
    cgi_executable = getCgiExecutable(script_path);
    if (cgi_executable.empty()) {
        response.generateErrorPage(request.server, 500);
        return response;
    }

    // Check if script exists and is executable
    std::cout << "Script to check: " << script_path.c_str() << std::endl;
    if (access(script_path.c_str(), F_OK) != 0) {
        response.generateErrorPage(request.server, 404);
        return response;
    }
    
    if (access(script_path.c_str(), X_OK) != 0) {
        response.generateErrorPage(request.server, 403);
        return response;
    }

    // Create pipes for communication
    int pipe_in[2];   // send to CGI
    int pipe_out[2];  // receiving from CGI
    
    // Create output pipe first (always needed)
    if (pipe(pipe_out) < 0) {
        response.generateErrorPage(request.server, 500);
        return response;
    }

    // For POST, use file instead of pipe for input
    std::string input_file;
    if (request.method == "POST") {
        // NOTE: This line should be changed to the generated by Abdlkader i.e. request.cgi_file_path
        input_file = "./test_file_for_cgi.txt";

        std::ifstream input(input_file.c_str());
        if (!input.is_open()) {
            close(pipe_out[0]);
            close(pipe_out[1]);
            response.generateErrorPage(request.server, 500);
            return response;
        }
        input.close();
    } else {
        // For non-POST requests, create input pipe
        if (pipe(pipe_in) < 0) {
            close(pipe_out[0]);
            close(pipe_out[1]);
            response.generateErrorPage(request.server, 500);
            return response;
        }
    }

    // Build environment variables and arguments
    char** args = buildArguments();
    char** env = buildEnvVariables();
    
/////// TEST: print env and args
std::cout << "I'll excute the script: " << args[0] << std::endl;
std::cout << "Using the following env:" << std::endl;
for (int i = 0; env && env[i]; i++) {
    std::cout << env[i] << std::endl;
}
/////// TEST: end

    // Fork and execute CGI
    int pid = fork();

    if (pid < 0) {
        // fork failed
        if (request.method != "POST") {
            close(pipe_in[0]);
            close(pipe_in[1]);
        } else {
            // remove the file given by Abdlkader (request.input_file)
            // std::remove()
        }
        close(pipe_out[0]);
        close(pipe_out[1]);
        freeEnvArray(args);
        freeEnvArray(env);
	response.generateErrorPage(request.server, 500);
	return response;
    }

    if (pid == 0) {
        //child
        if (request.method == "POST") {
            int fd = open(input_file.c_str(), O_RDONLY);
            if (fd >= 0) {
                dup2(fd, STDIN_FILENO);
                close(fd);
            }
        } else {
            dup2(pipe_in[0], STDIN_FILENO);
            close (pipe_in[0]);
            close (pipe_in[1]);
        }

        dup2(pipe_out[1], STDOUT_FILENO);
        close (pipe_out[0]);
        close (pipe_out[1]);
        
        std::string script_dir = script_path.substr(0, script_path.find_last_of('/'));
        if (!script_dir.empty()) {
            chdir(script_dir.c_str());
        }

        std::string script_filename = script_path.substr(script_path.find_last_of('/') + 1);

        char* new_args[3];
        new_args[0] = args[0];
        new_args[1] = const_cast<char*>(script_filename.c_str());
        new_args[2] = NULL;

        execve(cgi_executable.c_str(), new_args, env);

        perror("execve");
        exit (EXIT_FAILURE);
    }

    // parent
    if (request.method != "POST") {
        close (pipe_in[0]);
        close (pipe_in[1]);
    }
    close (pipe_out[1]);
   
    int status;
    bool success = waitForCgiWithTimeout(pid, &status);
    
    if (!success) {
        close(pipe_out[0]);
        if (request.method == "POST") {
            // NOTE: should delete the file here
            // std::remove(input_file.c_str());
        }
        freeEnvArray(args);
        freeEnvArray(env);
	response.generateErrorPage(request.server, 500);
	return response;
    }

    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        close(pipe_out[0]);
        if (request.method == "POST") {
            // NOTE: should delete the file here
            // std::remove(input_file.c_str());
        }
        freeEnvArray(args);
        freeEnvArray(env);
	response.generateErrorPage(request.server, 500);
	return response;
    }

    // Read CGI output
    std::string cgi_output;
    char buffer[BUFFERREADSIZE];
    ssize_t bytes_read;

    while ((bytes_read = read(pipe_out[0], buffer, sizeof(buffer))) > 0) {
        cgi_output.append(buffer, bytes_read);
    }

    close (pipe_out[0]);

    // clean up
    if (request.method == "POST") {
        // NOTE: should delete the file here
        // std::remove(input_file.c_str());
    }
    freeEnvArray(args);
    freeEnvArray(env);

    if (cgi_output.empty()) {
        response.generateErrorPage(request.server, 500);
        return response;
    }

    // Set default status if not set by CGI
    response.setStatusCode(200);

    // Parse headers from CGI output
    parseHeaders(cgi_output, response);

    // Parse headers from CGI output
    // This parser should check for two things
    // 1_ stat --> change state
    // 2_ location if so change stats code accordingly
    // 3_ content-length : this can be discarded since I calculate it when I want to set the body
    
    // Extract body
    std::string body = extractBody(cgi_output);
    
    response.writeStringToBuffer(body);

    return response;
}

void CgiHandler::parseHeaders(const std::string& cgi_output, Response& response) const {
    size_t header_end = cgi_output.find("\r\n\r\n");
    if (header_end == std::string::npos) {
        header_end = cgi_output.find("\n\n");
        if (header_end == std::string::npos) {
            return;
        }
    }

    // ...
}


std::string CgiHandler::extractBody(const std::string& cgi_output) const {
    size_t body_start = cgi_output.find("\r\n\r\n");
    if (body_start != std::string::npos) {
        return cgi_output.substr(body_start + 4);
    }

    body_start = cgi_output.find("\n\n");
    if (body_start != std::string::npos) {
        return cgi_output.substr(body_start + 2);
    }
    
    return cgi_output;
}

bool CgiHandler::waitForCgiWithTimeout(pid_t pid, int* status) const {
    time_t start_time = time(NULL);

    while (true) {
        int result = waitpid(pid, status, WNOHANG); // WNOHANG: return immediately if no child has exited.

        if (result > 0) {
            // Child has terminated
            return true;
        } else if (result < 0) {
            // Error occurred
            return false;
        }

        // check time return false
        if (time(NULL) - start_time >= CGI_TIMEOUT) {
            kill (pid, SIGKILL);
            waitpid(pid, status, 0);
            return false;
            // and return false
        }
    }
    // we should never reach this line
    return true;
}

char** CgiHandler::buildEnvVariables () const {
    std::vector<std::string> env_strings;

    env_strings.push_back("REQUEST_METHOD=" + request.method);
    env_strings.push_back("SCRIPT_FILENAME=" + script_path);
    env_strings.push_back("SCRIPT_NAME=" + request.target);
    env_strings.push_back("QUERY_STRING=" + request.query);
    env_strings.push_back("SERVER_PROTOCOL=" + request.version);
    env_strings.push_back("GATEWAY_INTERFACE=CGI/1.1");

    const std::pair<std::string, std::string>& listen = request.server.getListen()[0];
    env_strings.push_back("SERVER_NAME=" + listen.first);
    env_strings.push_back("SERVER_PORT=" + listen.second);

    // If method is POST get set CONTENT_LENGTH
    // check if request.has_content_length
    // set --> CONTENT_LENGTH= + request.content_length

    // Content-Type from headers
    map_t::const_iterator content_type = request.headers.find("content-type");
    if (content_type != request.headers.end()) {
        env_strings.push_back("CONTENT_TYPE=" + content_type->second);
    }

    // HTTP headers - these need to be convert to HTTP_* format
    // 4.1.18.  Protocol-Specific Meta-Variables (RFC 3785)

    char** env = new char*[env_strings.size() + 1];
    for (size_t i = 0; i < env_strings.size(); ++i) {
        env[i] = new char[env_strings[i].length() + 1];
        std::strcpy(env[i], env_strings[i].c_str());
    }
    env[env_strings.size()] = NULL;
    
    return env;
}

char** CgiHandler::buildArguments() const {
    char** args = new char*[3];
    
    args[0] = new char[cgi_executable.length() + 1];
    std::strcpy(args[0], cgi_executable.c_str());
    
    args[1] = NULL;
    
    args[2] = NULL;
    return args;
}

void CgiHandler::freeEnvArray(char** env) const {
    if (!env) return;
    for (int i = 0; env[i] != NULL; ++i) {
        delete[] env[i];
    }
    delete[] env;
}
